"""
Takes a list of domains, and adds tracking to their status. Checks if
- there are DNS entries
- the site responds to HTTP
- the site responds to HTTPS
- the certificate is valid
- the timestamp of the last valid response

Input formats can be a JSON list or the JSON file generated by this script, for repeat checks.
"""
import datetime as dt
import json
import socket
from contextlib import suppress

import click
import requests
import urllib3
from tqdm import tqdm


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


@click.group()
@click.version_option()
def cli():
    "Check availability of a set of domains"


@cli.command()
@click.option(
    "-s",
    "--source",
    type=click.Path(file_okay=True, dir_okay=False, allow_dash=False),
    default="domains.json",
    help="Path to load domains from and to save them after processing.",
)
@click.option(
    "--remove-success", type=bool, default=False, help="Only keep error cases."
)
def check(source, remove_success):
    """ Run a check on the existing domains. """
    domains = get_domains(source)
    click.echo(f"Found {len(domains)} domains.")
    check_domains(domains, source, records_only=records_only)
    if remove_success:
        domains = [d for d in domains if not d["valid_ssl"]]
    save_domains(domains, source)
    click.echo(f"Saved {len(domains)} domains.")


@cli.command()
@click.option(
    "-s",
    "--source",
    type=click.Path(file_okay=True, dir_okay=False, allow_dash=False),
    default="domains.json",
    help="Path to load domains from and to save them after processing.",
)
def report(source):
    """ Report the current results. """
    domains = get_domains(source)

    def percent(number, total=len(domains)):
        value = number * 100 / total
        return f"{value:.3}%"

    seen_count = len([d for d in domains if d["last_seen"]])
    ssl_count = len([d for d in domains if d["valid_ssl"]])
    v6_count = len([d for d in domains if d["has_dns6"]])
    table = []
    table.append(("Seen", str(seen_count), percent(seen_count)))
    table.append(("HTTPS", str(ssl_count), percent(ssl_count)))
    table.append(("v6", str(v6_count), percent(v6_count)))
    table.append(("Total", str(len(domains)), ""))

    for row in table:
        print(row[0].ljust(10) + row[1].rjust(10) + row[2].rjust(10))


def get_domains(path):
    with open(path) as f:
        content = json.load(f)
    if not isinstance(content, list):
        raise Exception(f"Incorrect format of {path}")
    return [normalise_domain(entry) for entry in content]


def normalise_domain(data):
    if isinstance(data, str):
        data = {"domain": data}
    if not isinstance(data, dict):
        raise Exception(f"Incorrect format! {data} is not a dictionary.")
    result = {
        key: data.get(key)
        for key in (
            "domain",
            "last_seen",
            "last_success",
            "has_dns4",
            "has_dns6",
            "has_http",
            "has_ssl",
            "valid_ssl",
        )
    }
    for timestamp in ("last_seen", "last_success"):
        if result[timestamp]:
            result[timestamp] = dt.datetime.strptime(
                result[timestamp], "%Y-%m-%dT%H:%M:%S.%f"
            )
    return result


def save_domains(data, path):
    def sensible(value):
        if isinstance(value, dt.datetime):
            return value.isoformat()

    with open(path, "w") as f:
        json.dump(data, f, indent=4, default=sensible)


def check_domain(data):
    domain = data["domain"]
    data["has_dns4"] = False
    data["has_dns6"] = False
    try:
        response = socket.getaddrinfo(domain, 80)
    except:
        data["has_http"] = False
        data["has_ssl"] = False
        data["valid_ssl"] = False
        return

    for entry in response:
        if entry[0] == socket.AddressFamily.AF_INET:
            data["has_dns4"] = True
        elif entry[0] == socket.AddressFamily.AF_INET6:
            data["has_dns6"] = True

    if not data["has_dns4"]:
        return

    try:
        response = requests.get(f"http://{domain}", timeout=10)
        response.raise_for_status()
        data["has_http"] = True
        data["last_seen"] = dt.datetime.now()
    except:
        data["has_http"] = False
        data["has_ssl"] = False
        data["valid_ssl"] = False
        return

    data["has_ssl"] = False
    data["valid_ssl"] = False
    try:
        response = requests.get(f"https://{domain}", timeout=10)
        response.raise_for_status()
        data["has_ssl"] = True
        data["valid_ssl"] = True
        data["last_success"] = dt.datetime.now()
        return
    except requests.exceptions.SSLError:
        with suppress(Exception):
            response = requests.get(f"https://{domain}", verify=False, timeout=10)
            response.raise_for_status()
            data["has_ssl"] = True
            data["valid_ssl"] = False
    except Exception:
        pass


def check_domains(data, path):
    progress_bar = tqdm(desc="Checking domains", total=len(data))
    last_save = dt.datetime.now()
    check_interval = dt.timedelta(minutes=5)
    for domain in data:
        check_domain(domain)
        progress_bar.update(1)
        if dt.datetime.now() - last_save > check_interval:
            click.echo("Checkpoint reached, saving data.")
            save_domains(data, path)
            last_save = dt.datetime.now()
    progress_bar.close()


cli()
