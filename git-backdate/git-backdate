#!/bin/env python

import datetime
import math
import os
import random
import re
import sys
from subprocess import call, check_call, check_output

import click


def get_commits(commitish):
    """If commitish is a range, return a list of commits in that range."""
    if ".." in commitish:
        result = check_output(["git", "rev-list", commitish]).splitlines()
        # git rev-list returns commits in reverse chronological order
        return result[::-1]
    else:
        return [commitish]


def _parse_date(dateish):
    """Parse a dateish string into a datetime object."""
    if not re.match(r"\d{4}-\d{2}-\d{2}", dateish):
        dateish = (
            check_output(["date", "--iso-8601", "--date", dateish]).strip().decode()
        )
    return datetime.datetime.strptime(dateish, "%Y-%m-%d").date()


def get_dates(dateish):
    """Dateish can be an iso date, or two separated by .., or a human readable date."""
    if ".." in dateish:
        return [_parse_date(d) for d in dateish.split("..")]
    else:
        result = _parse_date(dateish)
        return [result, result]


def _get_timestamp(date, min_hour, max_hour, greater_than=None):
    """Return a random timestamp on the given date, between min_hour and max_hour."""
    if greater_than is None:
        greater_than = datetime.datetime.combine(date, datetime.time.min)
    min_timestamp = datetime.datetime.combine(date, datetime.time(min_hour))
    max_timestamp = datetime.datetime.combine(date, datetime.time(max_hour, 59))
    min_timestamp = min_timestamp if min_timestamp > greater_than else greater_than
    interval = (max_timestamp - min_timestamp).total_seconds()
    return min_timestamp + datetime.timedelta(seconds=random.randint(0, interval))


def rebase_in_progress():
    """Return True if a rebase is in progress."""
    git_root = check_output(["git", "rev-parse", "--show-toplevel"]).strip().decode()
    return os.path.exists(
        os.path.join(git_root, ".git", "rebase-merge")
    ) or os.path.exists(os.path.join(git_root, ".git", "rebase-apply"))


def rewrite_history(commits, start, end, business_hours, is_rebase):
    days = [
        start + datetime.timedelta(days=day) for day in range((end - start).days + 1)
    ]
    min_hour = 19
    max_hour = 23
    if business_hours:
        # only weekdays
        days = [day for day in days if day.weekday() < 5]
        min_hour = 9
        max_hour = 17
    duration = len(days)
    commits_per_day = math.ceil(len(commits) / duration)
    last_timestamp = None
    commit_count = len(commits)
    for commit_index in range(commit_count):
        progress = (commit_index + 1) / commit_count
        # first, choose the date
        if commit_index == 0 or duration == 1:
            date = start
            day_progress = 0
        else:
            if commit_index == commit_count - 1:
                date = end
            else:
                # select date by index
                date_index = round(progress * (duration - 1))
                date = days[date_index]
            if date == last_timestamp.date():
                day_progress += 1
            else:
                day_progress = 0

        # if we only have one commit per day at most, we can use the whole day.
        # otherwise, we need to limit the time range further to avoid collisions.
        if commits_per_day <= 1:
            _max_hour = max_hour
        else:
            _max_hour = min_hour + int(
                (max_hour - min_hour) * (day_progress / commits_per_day)
            )

        # then, choose the time
        timestamp = _get_timestamp(
            date, min_hour=min_hour, max_hour=_max_hour, greater_than=last_timestamp
        )

        # Set both the author and committer dates
        check_call(
            [
                "git",
                "commit",
                "--amend",
                "--date",
                timestamp.isoformat(),
                "--no-edit",
            ],
            env=dict(os.environ, GIT_COMMITTER_DATE=timestamp.isoformat()),
        )
        last_timestamp = timestamp
        if is_rebase:
            check_call(["git", "rebase", "--continue"])


def normalize_commit(commit):
    return check_output(["git", "rev-parse", commit]).strip().decode()


def is_equal(commit, commitish):
    return normalize_commit(commit) == normalize_commit(commitish)


@click.command()
@click.argument(
    "commits",
    default="HEAD",
)
@click.argument(
    "dates",
    default="now",
)
@click.option(
    "--business-hours",
    is_flag=True,
    help="Backdate to business hours: Mon–Fri, 9–17",
    default=True,
)
@click.option(
    "--outside-business-hours",
    is_flag=True,
    help="Backdate to outside business hours: 19–23, every day of the week",
    default=False,
)
def main(commits, dates, business_hours, outside_business_hours):
    """Backdate a commit or range of commit to a date or range of dates.
    Put commit dates to be within of business hours (including skipping weekends), or outside of business hours.

    COMMITS is a commit or range of commits to backdate. If only one commit is given, it will be used as the end of the range.

    DATES is a date or range of dates to backdate to, can use human readable dates. Separate by .., eg "1 week ago..yesterday"
    """

    if business_hours and outside_business_hours:
        print("Cannot use both business hours and outside business hours")
        sys.exit(1)

    commits = [normalize_commit(c) for c in get_commits(commits)]
    start, end = get_dates(dates)

    if not commits:
        print("No commits found")
        sys.exit(1)

    # We need to rebase if we have more than one commit, or if the one commit is not the current commit
    if len(commits) > 1:
        is_rebase = True
    else:
        is_rebase = not is_equal(commits[0], "HEAD")

    # Make sure our current commit sits on top of the commit range with --is-ancestor
    if is_rebase:
        for commit in commits:
            is_head = is_equal(commit, "HEAD")
            is_ancestor = call(["git", "merge-base", "--is-ancestor", "HEAD", commit])
            if not is_head and not is_ancestor:
                print(f"Current commit is not an ancestor of the commit range {commit}")
                sys.exit(1)
        # Start the rebase
        # We construct a sed command to change only our commits to edit
        short_commits = [c[:7] for c in commits]
        sed_command = rf"sed -i -re 's/^pick ({'|'.join(short_commits)})/edit \1/'"
        check_call(
            ["git", "rebase", "-i", commits[0] + "^"],
            env=dict(os.environ, GIT_SEQUENCE_EDITOR=sed_command),
        )

    # Global try/except to make sure we reset the repo if we fail
    try:
        rewrite_history(
            commits,
            start,
            end,
            business_hours=business_hours,
            is_rebase=is_rebase,
        )
    except Exception:
        check_call(["git", "rebase", "--abort"])
        raise


if __name__ == "__main__":
    main()
