#!/bin/env python
""" This script backdates a commit or range of commit to a date or range of dates.
It can put commit dates to be within of business hours, or outside of business hours."""

import datetime
import math
import os
import random
import re
import sys
from subprocess import call, check_call, check_output

import click


def get_commits(commitish):
    """If commitish is a range, return a list of commits in that range."""
    if ".." in commitish:
        result = check_output(["git", "rev-list", commitish]).splitlines()
        # git rev-list returns commits in reverse chronological order
        return result[::-1]
    else:
        return [commitish]


def _parse_date(dateish):
    """Parse a dateish string into a datetime object."""
    if not re.match(r"\d{4}-\d{2}-\d{2}", dateish):
        dateish = (
            check_output(["date", "--iso-8601", "--date", dateish]).strip().decode()
        )
    return datetime.datetime.strptime(dateish, "%Y-%m-%d").date()


def get_dates(dateish):
    """Dateish can be an iso date, or two separated by .., or a human readable date."""
    if ".." in dateish:
        return [_parse_date(d) for d in dateish.split("..")]
    else:
        result = _parse_date(dateish)
        return [result, result]


def _get_timestamp(date, min_hour, max_hour, greater_than=None):
    """Return a random timestamp on the given date, between min_hour and max_hour."""
    if greater_than is None:
        greater_than = datetime.datetime.combine(date, datetime.time.min)
    min_timestamp = datetime.datetime.combine(date, datetime.time(min_hour))
    max_timestamp = datetime.datetime.combine(date, datetime.time(max_hour, 59))
    min_timestamp = min_timestamp if min_timestamp > greater_than else greater_than
    interval = (max_timestamp - min_timestamp).total_seconds()
    return min_timestamp + datetime.timedelta(seconds=random.randint(0, interval))


def rebase_in_progress():
    """Return True if a rebase is in progress."""
    git_root = check_output(["git", "rev-parse", "--show-toplevel"]).strip().decode()
    return os.path.exists(
        os.path.join(git_root, ".git", "rebase-merge")
    ) or os.path.exists(os.path.join(git_root, ".git", "rebase-apply"))


def rewrite_history(commits, start, end, dry_run, business_hours, is_rebase):
    days = [
        start + datetime.timedelta(days=day) for day in range((end - start).days + 1)
    ]
    min_hour = 19
    max_hour = 23
    if business_hours:
        # only weekdays
        days = [day for day in days if day.weekday() < 5]
        min_hour = 9
        max_hour = 17
    duration = len(days)
    commits_per_day = math.ceil(len(commits) / duration)
    last_timestamp = None
    commit_count = len(commits)
    while commits:
        # if the commit is part of our commits of interest, we need to continue the rebase
        commit = normalize_commit("HEAD")
        if commit not in commits:
            if is_rebase:
                check_call(["git", "rebase", "--continue"])
            return
        progress = len(commits) / commit_count
        # first, choose the date
        if len(commits) == commit_count or duration == 1:
            date = start
            day_progress = 0
        else:
            if len(commits) == 1:
                date = end
            else:
                # select date by index
                date_index = round(progress * (duration - 1))
                date = days[date_index]
            if date == last_timestamp.date():
                day_progress += 1
            else:
                day_progress = 0

        # if we only have one commit per day at most, we can use the whole day.
        # otherwise, we need to limit the time range further to avoid collisions.
        if commits_per_day <= 1:
            _max_hour = max_hour
        else:
            _max_hour = min_hour + int(
                (max_hour - min_hour) * (day_progress / commits_per_day)
            )

        # then, choose the time
        timestamp = _get_timestamp(
            date, min_hour=min_hour, max_hour=_max_hour, greater_than=last_timestamp
        )

        # finally, set the date
        if dry_run:
            print("Would set {} to {}".format(commit, timestamp))
        else:
            # Set both the author and committer dates
            check_call(
                [
                    "git",
                    "commit",
                    "--amend",
                    "--date",
                    timestamp.isoformat(),
                    "--no-edit",
                ],
                env=dict(os.environ, GIT_COMMITTER_DATE=timestamp.isoformat()),
            )
        last_timestamp = timestamp
        commits.remove(commit)
        if is_rebase:
            check_call(["git", "rebase", "--continue"])


def normalize_commit(commit):
    return check_output(["git", "rev-parse", commit]).strip().decode()


def is_equal(commit, commitish):
    return normalize_commit(commit) == normalize_commit(commitish)


@click.command()
@click.option(
    "--commit", default="HEAD", help="Commit or range of commits to backdate."
)
@click.option(
    "--date",
    default="now",
    help="Date or range of dates to backdate to, can use human readable dates. Separate by ..",
)
@click.option("--business-hours", is_flag=True, help="Backdate to business hours")
@click.option(
    "--outside-business-hours", is_flag=True, help="Backdate to outside business hours"
)
@click.option("--dry-run", is_flag=True, help="Do not actually change the commit dates")
def main(commit, date, business_hours, outside_business_hours, dry_run):
    if business_hours and outside_business_hours:
        print("Cannot use both business hours and outside business hours")
        sys.exit(1)

    commits = [normalize_commit(c) for c in get_commits(commit)]
    start, end = get_dates(date)

    if not commits:
        print("No commits found")
        sys.exit(1)

    # We need to rebase if we have more than one commit, or if the one commit is not the current commit
    if len(commits) > 1:
        is_rebase = True
    else:
        is_rebase = not is_equal(commits[0], "HEAD")

    # Make sure our current commit sits on top of the commit range with --is-ancestor
    if is_rebase:
        for commit in commits:
            is_head = is_equal(commit, "HEAD")
            is_ancestor = call(
                ["git", "merge-base", "--is-ancestor", "HEAD", commit]
            )
            if not is_head and not is_ancestor:
                print(f"Current commit is not an ancestor of the commit range {commit}")
                sys.exit(1)
        # Start the rebase
        # We construct a sed command to change only our commits to edit
        short_commits = [c[:7] for c in commits]
        sed_command = rf"sed -i -re 's/^pick ({'|'.join(short_commits)})/edit \1/'"
        check_call(
            ["git", "rebase", "-i", commits[0] + "^"],
            env=dict(os.environ, GIT_SEQUENCE_EDITOR=sed_command),
        )

    # Global try/except to make sure we reset the repo if we fail
    try:
        rewrite_history(
            commits,
            start,
            end,
            dry_run=dry_run,
            business_hours=business_hours,
            is_rebase=is_rebase,
        )
    except Exception:
        check_call(["git", "rebase", "--abort"])
        raise


if __name__ == "__main__":
    main()
